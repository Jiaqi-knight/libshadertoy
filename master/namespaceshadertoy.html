<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libshadertoy: shadertoy Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libshadertoy
   &#160;<span id="projectnumber">1.0.0~rc7</span>
   </div>
   <div id="projectbrief">A C++ library for multipass OpenGL rendering on desktop</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceshadertoy.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">shadertoy Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base namespace for libshadertoy.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceshadertoy_1_1buffers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshadertoy_1_1buffers.html">buffers</a></td></tr>
<tr class="memdesc:namespaceshadertoy_1_1buffers"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of rendering buffers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceshadertoy_1_1compiler"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshadertoy_1_1compiler.html">compiler</a></td></tr>
<tr class="memdesc:namespaceshadertoy_1_1compiler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shader source compiler types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceshadertoy_1_1geometry"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshadertoy_1_1geometry.html">geometry</a></td></tr>
<tr class="memdesc:namespaceshadertoy_1_1geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geometry primitives. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceshadertoy_1_1gl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshadertoy_1_1gl.html">gl</a></td></tr>
<tr class="memdesc:namespaceshadertoy_1_1gl"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenGL wrapper helpers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceshadertoy_1_1inputs"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshadertoy_1_1inputs.html">inputs</a></td></tr>
<tr class="memdesc:namespaceshadertoy_1_1inputs"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer input class definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceshadertoy_1_1members"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshadertoy_1_1members.html">members</a></td></tr>
<tr class="memdesc:namespaceshadertoy_1_1members"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap chain member class definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceshadertoy_1_1utils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshadertoy_1_1utils.html">utils</a></td></tr>
<tr class="memdesc:namespaceshadertoy_1_1utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Miscellaneous utilities. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structshadertoy_1_1basic__size.html">basic_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 2D size.  <a href="structshadertoy_1_1basic__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshadertoy_1_1draw__state.html">draw_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the OpenGL state that affects buffer rendering.  <a href="classshadertoy_1_1draw__state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshadertoy_1_1explicit__size.html">explicit_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a size object, wrapped in a <a class="el" href="classshadertoy_1_1size__ref__interface.html" title="Base interface for objects that can return a size object. ">size_ref_interface</a>.  <a href="classshadertoy_1_1explicit__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshadertoy_1_1explicit__size__ref.html">explicit_size_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a reference to a size object, wrapped in a <a class="el" href="classshadertoy_1_1size__ref__interface.html" title="Base interface for objects that can return a size object. ">size_ref_interface</a>.  <a href="classshadertoy_1_1explicit__size__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshadertoy_1_1getter__size__ref.html">getter_size_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a reference to a size object that is obtained through a callback.  <a href="classshadertoy_1_1getter__size__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structshadertoy_1_1input__resource.html">input_resource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a program input resource.  <a href="structshadertoy_1_1input__resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshadertoy_1_1io__resource.html">io_resource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of textures used as input and outputs of a buffer.  <a href="classshadertoy_1_1io__resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structshadertoy_1_1output__buffer__spec.html">output_buffer_spec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the properties of a texture to use as an output buffer.  <a href="structshadertoy_1_1output__buffer__spec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structshadertoy_1_1output__resource.html">output_resource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a program output resource.  <a href="structshadertoy_1_1output__resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshadertoy_1_1program__input.html">program_input</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an input texture to shader code.  <a href="classshadertoy_1_1program__input.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshadertoy_1_1program__interface.html">program_interface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the set of interfaces of an OpenGL program.  <a href="classshadertoy_1_1program__interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structshadertoy_1_1program__resource.html">program_resource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an OpenGL program interface resource.  <a href="structshadertoy_1_1program__resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshadertoy_1_1render__context.html">render_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent a context for rendering a specific ShaderToy program.  <a href="classshadertoy_1_1render__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshadertoy_1_1resource__interface.html">resource_interface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic program interface representation.  <a href="classshadertoy_1_1resource__interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshadertoy_1_1shader__compiler.html">shader_compiler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ShaderCompiler is a class for compiling shaders while maintaining file names and line numbers in error messages returned by the OpenGL GLSL compiler.  <a href="classshadertoy_1_1shader__compiler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshadertoy_1_1shadertoy__error.html">shadertoy_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base error class for libshadertoy errors.  <a href="classshadertoy_1_1shadertoy__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshadertoy_1_1size__ref__interface.html">size_ref_interface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base interface for objects that can return a size object.  <a href="classshadertoy_1_1size__ref__interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshadertoy_1_1size__ref__interface__ref.html">size_ref_interface_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a reference to another <a class="el" href="classshadertoy_1_1size__ref__interface.html" title="Base interface for objects that can return a size object. ">size_ref_interface</a> object.  <a href="classshadertoy_1_1size__ref__interface__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshadertoy_1_1swap__chain.html">swap_chain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a swap chain. A swap chain specifies how buffers are rendered to obtain the final result.  <a href="classshadertoy_1_1swap__chain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structshadertoy_1_1uniform__resource.html">uniform_resource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a uniform interface resource.  <a href="structshadertoy_1_1uniform__resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acf320ab96814324ce2e033b901785897"><td class="memItemLeft" align="right" valign="top">typedef std::variant&lt; std::string, GLint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshadertoy.html#acf320ab96814324ce2e033b901785897">output_name_t</a></td></tr>
<tr class="memdesc:acf320ab96814324ce2e033b901785897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name specification of a given buffer output.  <a href="#acf320ab96814324ce2e033b901785897">More...</a><br /></td></tr>
<tr class="separator:acf320ab96814324ce2e033b901785897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3747047719376bb7120d2ae3682208ff"><td class="memItemLeft" align="right" valign="top">typedef std::tuple&lt; std::string, GLint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshadertoy.html#a3747047719376bb7120d2ae3682208ff">output_name_info_t</a></td></tr>
<tr class="memdesc:a3747047719376bb7120d2ae3682208ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name information of a buffer output.  <a href="#a3747047719376bb7120d2ae3682208ff">More...</a><br /></td></tr>
<tr class="separator:a3747047719376bb7120d2ae3682208ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d488120d523ab85b17204180dd29815"><td class="memItemLeft" align="right" valign="top">typedef std::variant&lt; int, glm::ivec2, glm::ivec3, glm::ivec4, unsigned int, glm::uvec2, glm::uvec3, glm::uvec4, float, glm::vec2, glm::vec3, glm::vec4, bool, glm::bvec2, glm::bvec3, glm::bvec4, glm::mat2, glm::mat3, glm::mat4, glm::mat2x3, glm::mat2x4, glm::mat3x2, glm::mat3x4, glm::mat4x2, glm::mat4x3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshadertoy.html#a3d488120d523ab85b17204180dd29815">uniform_variant</a></td></tr>
<tr class="memdesc:a3d488120d523ab85b17204180dd29815"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenGL uniform value variant type.  <a href="#a3d488120d523ab85b17204180dd29815">More...</a><br /></td></tr>
<tr class="separator:a3d488120d523ab85b17204180dd29815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01797e13368bbb72b73915712ab13383"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classshadertoy_1_1resource__interface.html">resource_interface</a>&lt; <a class="el" href="structshadertoy_1_1uniform__resource.html">uniform_resource</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshadertoy.html#a01797e13368bbb72b73915712ab13383">uniform_interface</a></td></tr>
<tr class="memdesc:a01797e13368bbb72b73915712ab13383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform resource interface type.  <a href="#a01797e13368bbb72b73915712ab13383">More...</a><br /></td></tr>
<tr class="separator:a01797e13368bbb72b73915712ab13383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7764f50fc44caa73b3f605cfe6045f6c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classshadertoy_1_1resource__interface.html">resource_interface</a>&lt; <a class="el" href="structshadertoy_1_1input__resource.html">input_resource</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshadertoy.html#a7764f50fc44caa73b3f605cfe6045f6c">input_interface</a></td></tr>
<tr class="memdesc:a7764f50fc44caa73b3f605cfe6045f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program input resource interface type.  <a href="#a7764f50fc44caa73b3f605cfe6045f6c">More...</a><br /></td></tr>
<tr class="separator:a7764f50fc44caa73b3f605cfe6045f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f85eb0f89bbd8481c9b9c2feba974a7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classshadertoy_1_1resource__interface.html">resource_interface</a>&lt; <a class="el" href="structshadertoy_1_1output__resource.html">output_resource</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshadertoy.html#a8f85eb0f89bbd8481c9b9c2feba974a7">output_interface</a></td></tr>
<tr class="memdesc:a8f85eb0f89bbd8481c9b9c2feba974a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program output resource interface type.  <a href="#a8f85eb0f89bbd8481c9b9c2feba974a7">More...</a><br /></td></tr>
<tr class="separator:a8f85eb0f89bbd8481c9b9c2feba974a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366ee9c2e6313d8e97c0dd2015a68777"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structshadertoy_1_1basic__size.html">basic_size</a>&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshadertoy.html#a366ee9c2e6313d8e97c0dd2015a68777">rsize</a></td></tr>
<tr class="memdesc:a366ee9c2e6313d8e97c0dd2015a68777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer render size.  <a href="#a366ee9c2e6313d8e97c0dd2015a68777">More...</a><br /></td></tr>
<tr class="separator:a366ee9c2e6313d8e97c0dd2015a68777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bdc6490d5b40b42f8029734b8cac4b"><td class="memItemLeft" align="right" valign="top">typedef std::unique_ptr&lt; <a class="el" href="classshadertoy_1_1size__ref__interface.html">size_ref_interface</a>&lt; unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshadertoy.html#ab8bdc6490d5b40b42f8029734b8cac4b">rsize_ref</a></td></tr>
<tr class="memdesc:ab8bdc6490d5b40b42f8029734b8cac4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer render size reference.  <a href="#ab8bdc6490d5b40b42f8029734b8cac4b">More...</a><br /></td></tr>
<tr class="separator:ab8bdc6490d5b40b42f8029734b8cac4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac4c1f4fe8dcc53fe2ba932791c8ec663"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshadertoy.html#ac4c1f4fe8dcc53fe2ba932791c8ec663">member_swap_policy</a> { <a class="el" href="namespaceshadertoy.html#ac4c1f4fe8dcc53fe2ba932791c8ec663a7107a37e8441dc14d1e245f619bcd595">member_swap_policy::single_buffer</a>, 
<a class="el" href="namespaceshadertoy.html#ac4c1f4fe8dcc53fe2ba932791c8ec663a6e39fd4796fbc626d7bd76820de8cc94">member_swap_policy::double_buffer</a>, 
<a class="el" href="namespaceshadertoy.html#ac4c1f4fe8dcc53fe2ba932791c8ec663a2256c61130217978497e785e33b0b167">member_swap_policy::default_framebuffer</a>
 }<tr class="memdesc:ac4c1f4fe8dcc53fe2ba932791c8ec663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the texture swapping policy in a swap chain.  <a href="namespaceshadertoy.html#ac4c1f4fe8dcc53fe2ba932791c8ec663">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac4c1f4fe8dcc53fe2ba932791c8ec663"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6d03ad55240494ec0bbb2a21e3279d5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshadertoy.html#a6d03ad55240494ec0bbb2a21e3279d5f">operator==</a> (const <a class="el" href="namespaceshadertoy.html#a3747047719376bb7120d2ae3682208ff">output_name_info_t</a> &amp;name_info, const <a class="el" href="namespaceshadertoy.html#acf320ab96814324ce2e033b901785897">output_name_t</a> &amp;name)</td></tr>
<tr class="memdesc:a6d03ad55240494ec0bbb2a21e3279d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a name information object with a name specification.  <a href="#a6d03ad55240494ec0bbb2a21e3279d5f">More...</a><br /></td></tr>
<tr class="separator:a6d03ad55240494ec0bbb2a21e3279d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ace5daa976d97ddcd4d4257e58ae22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshadertoy.html#a35ace5daa976d97ddcd4d4257e58ae22">operator!=</a> (const <a class="el" href="namespaceshadertoy.html#a3747047719376bb7120d2ae3682208ff">output_name_info_t</a> &amp;name_info, const <a class="el" href="namespaceshadertoy.html#acf320ab96814324ce2e033b901785897">output_name_t</a> &amp;name)</td></tr>
<tr class="memdesc:a35ace5daa976d97ddcd4d4257e58ae22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a name information object with a name specification.  <a href="#a35ace5daa976d97ddcd4d4257e58ae22">More...</a><br /></td></tr>
<tr class="separator:a35ace5daa976d97ddcd4d4257e58ae22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72b0196439fee3a1bc113f54ad74a1a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac72b0196439fee3a1bc113f54ad74a1a"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classshadertoy_1_1program__input.html">program_input</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceshadertoy.html#ac72b0196439fee3a1bc113f54ad74a1a">make_input</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac72b0196439fee3a1bc113f54ad74a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <a class="el" href="classshadertoy_1_1program__input.html" title="Represents an input texture to shader code. ">program_input</a> according to the arguments to its constructor.  <a href="#ac72b0196439fee3a1bc113f54ad74a1a">More...</a><br /></td></tr>
<tr class="separator:ac72b0196439fee3a1bc113f54ad74a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c093077a39b284424fa74b605a58428"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4c093077a39b284424fa74b605a58428"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classshadertoy_1_1size__ref__interface.html">size_ref_interface</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceshadertoy.html#a4c093077a39b284424fa74b605a58428">make_ref</a> (const <a class="el" href="classshadertoy_1_1size__ref__interface.html">size_ref_interface</a>&lt; T &gt; &amp;int_ref)</td></tr>
<tr class="memdesc:a4c093077a39b284424fa74b605a58428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a reference to a <a class="el" href="classshadertoy_1_1size__ref__interface.html" title="Base interface for objects that can return a size object. ">size_ref_interface</a>&lt;T&gt;.  <a href="#a4c093077a39b284424fa74b605a58428">More...</a><br /></td></tr>
<tr class="separator:a4c093077a39b284424fa74b605a58428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbaec8af3bfacd1da05b43e1c3ed4b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cbaec8af3bfacd1da05b43e1c3ed4b3"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classshadertoy_1_1size__ref__interface.html">size_ref_interface</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceshadertoy.html#a6cbaec8af3bfacd1da05b43e1c3ed4b3">make_size</a> (const <a class="el" href="structshadertoy_1_1basic__size.html">basic_size</a>&lt; T &gt; &amp;size)</td></tr>
<tr class="memdesc:a6cbaec8af3bfacd1da05b43e1c3ed4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to construct <a class="el" href="classshadertoy_1_1explicit__size.html" title="Represents a size object, wrapped in a size_ref_interface. ">explicit_size</a> objects.  <a href="#a6cbaec8af3bfacd1da05b43e1c3ed4b3">More...</a><br /></td></tr>
<tr class="separator:a6cbaec8af3bfacd1da05b43e1c3ed4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585627de12dd33f83b734bcc0fcb7c1d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a585627de12dd33f83b734bcc0fcb7c1d"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classshadertoy_1_1size__ref__interface.html">size_ref_interface</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceshadertoy.html#a585627de12dd33f83b734bcc0fcb7c1d">make_size_ref</a> (const <a class="el" href="structshadertoy_1_1basic__size.html">basic_size</a>&lt; T &gt; &amp;size)</td></tr>
<tr class="memdesc:a585627de12dd33f83b734bcc0fcb7c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to construct <a class="el" href="classshadertoy_1_1explicit__size__ref.html" title="Represents a reference to a size object, wrapped in a size_ref_interface. ">explicit_size_ref</a> objects.  <a href="#a585627de12dd33f83b734bcc0fcb7c1d">More...</a><br /></td></tr>
<tr class="separator:a585627de12dd33f83b734bcc0fcb7c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d8f4b6358e1be1be77dfed1ccaf54a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Callable &gt; </td></tr>
<tr class="memitem:ab4d8f4b6358e1be1be77dfed1ccaf54a"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classshadertoy_1_1size__ref__interface.html">size_ref_interface</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceshadertoy.html#ab4d8f4b6358e1be1be77dfed1ccaf54a">make_size_getter</a> (Callable getter)</td></tr>
<tr class="memdesc:ab4d8f4b6358e1be1be77dfed1ccaf54a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to construct <a class="el" href="classshadertoy_1_1getter__size__ref.html" title="Represents a reference to a size object that is obtained through a callback. ">getter_size_ref</a> objects.  <a href="#ab4d8f4b6358e1be1be77dfed1ccaf54a">More...</a><br /></td></tr>
<tr class="separator:ab4d8f4b6358e1be1be77dfed1ccaf54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base namespace for libshadertoy. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a7764f50fc44caa73b3f605cfe6045f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7764f50fc44caa73b3f605cfe6045f6c">&#9670;&nbsp;</a></span>input_interface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classshadertoy_1_1resource__interface.html">resource_interface</a>&lt;<a class="el" href="structshadertoy_1_1input__resource.html">input_resource</a>&gt; <a class="el" href="namespaceshadertoy.html#a7764f50fc44caa73b3f605cfe6045f6c">shadertoy::input_interface</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program input resource interface type. </p>

</div>
</div>
<a id="a8f85eb0f89bbd8481c9b9c2feba974a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f85eb0f89bbd8481c9b9c2feba974a7">&#9670;&nbsp;</a></span>output_interface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classshadertoy_1_1resource__interface.html">resource_interface</a>&lt;<a class="el" href="structshadertoy_1_1output__resource.html">output_resource</a>&gt; <a class="el" href="namespaceshadertoy.html#a8f85eb0f89bbd8481c9b9c2feba974a7">shadertoy::output_interface</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program output resource interface type. </p>

</div>
</div>
<a id="a3747047719376bb7120d2ae3682208ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3747047719376bb7120d2ae3682208ff">&#9670;&nbsp;</a></span>output_name_info_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::tuple&lt;std::string, GLint&gt; <a class="el" href="namespaceshadertoy.html#a3747047719376bb7120d2ae3682208ff">shadertoy::output_name_info_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name information of a buffer output. </p>
<p>This type represents both the name and integer location of an output in a program. </p>

</div>
</div>
<a id="acf320ab96814324ce2e033b901785897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf320ab96814324ce2e033b901785897">&#9670;&nbsp;</a></span>output_name_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::variant&lt;std::string, GLint&gt; <a class="el" href="namespaceshadertoy.html#acf320ab96814324ce2e033b901785897">shadertoy::output_name_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name specification of a given buffer output. </p>
<p>This type designates a buffer output either by name or by integer location in the associated program. </p>

</div>
</div>
<a id="a366ee9c2e6313d8e97c0dd2015a68777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366ee9c2e6313d8e97c0dd2015a68777">&#9670;&nbsp;</a></span>rsize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structshadertoy_1_1basic__size.html">basic_size</a>&lt;unsigned int&gt; <a class="el" href="namespaceshadertoy.html#a366ee9c2e6313d8e97c0dd2015a68777">shadertoy::rsize</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer render size. </p>

</div>
</div>
<a id="ab8bdc6490d5b40b42f8029734b8cac4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8bdc6490d5b40b42f8029734b8cac4b">&#9670;&nbsp;</a></span>rsize_ref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::unique_ptr&lt;<a class="el" href="classshadertoy_1_1size__ref__interface.html">size_ref_interface</a>&lt;unsigned int&gt; &gt; <a class="el" href="namespaceshadertoy.html#ab8bdc6490d5b40b42f8029734b8cac4b">shadertoy::rsize_ref</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer render size reference. </p>

</div>
</div>
<a id="a01797e13368bbb72b73915712ab13383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01797e13368bbb72b73915712ab13383">&#9670;&nbsp;</a></span>uniform_interface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classshadertoy_1_1resource__interface.html">resource_interface</a>&lt;<a class="el" href="structshadertoy_1_1uniform__resource.html">uniform_resource</a>&gt; <a class="el" href="namespaceshadertoy.html#a01797e13368bbb72b73915712ab13383">shadertoy::uniform_interface</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uniform resource interface type. </p>

</div>
</div>
<a id="a3d488120d523ab85b17204180dd29815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d488120d523ab85b17204180dd29815">&#9670;&nbsp;</a></span>uniform_variant</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::variant&lt;int, glm::ivec2, glm::ivec3, glm::ivec4, unsigned int, glm::uvec2, glm::uvec3, glm::uvec4, float, glm::vec2, glm::vec3, glm::vec4, bool, glm::bvec2, glm::bvec3, glm::bvec4, glm::mat2, glm::mat3, glm::mat4, glm::mat2x3, glm::mat2x4, glm::mat3x2, glm::mat3x4, glm::mat4x2, glm::mat4x3&gt; <a class="el" href="namespaceshadertoy.html#a3d488120d523ab85b17204180dd29815">shadertoy::uniform_variant</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OpenGL uniform value variant type. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac4c1f4fe8dcc53fe2ba932791c8ec663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c1f4fe8dcc53fe2ba932791c8ec663">&#9670;&nbsp;</a></span>member_swap_policy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceshadertoy.html#ac4c1f4fe8dcc53fe2ba932791c8ec663">shadertoy::member_swap_policy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the texture swapping policy in a swap chain. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac4c1f4fe8dcc53fe2ba932791c8ec663a7107a37e8441dc14d1e245f619bcd595"></a>single_buffer&#160;</td><td class="fielddoc"><p>Rendering the target member will always be done in the same texture. </p>
<p>This is suited for buffers that only process inputs from other passes and which do not store state by rendering and reading their own output. Note that there might be a performance hit if the target pass is on the critical path. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac4c1f4fe8dcc53fe2ba932791c8ec663a6e39fd4796fbc626d7bd76820de8cc94"></a>double_buffer&#160;</td><td class="fielddoc"><p>Rendering the target member will be done in one of two alternating textures. </p>
<p>This is commonly known as ping-pong, which requires twice the memory but allows storing state in a single pass. It might also improve performance if the target pass is on the critical path and pipeline passes are required. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac4c1f4fe8dcc53fe2ba932791c8ec663a2256c61130217978497e785e33b0b167"></a>default_framebuffer&#160;</td><td class="fielddoc"><p>Rendering the target member will render directly to the default framebuffer. </p>
<p>If you do not want to store the results of a member to a texture for further usage, you can choose to render directly to the default framebuffer. This saves texture allocations, however the member's output will not be captured and cannot be used as an input to another member.</p>
<p>This only applies to members that are capable of rendering to a framebuffer. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac72b0196439fee3a1bc113f54ad74a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72b0196439fee3a1bc113f54ad74a1a">&#9670;&nbsp;</a></span>make_input()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classshadertoy_1_1program__input.html">program_input</a>&gt; shadertoy::make_input </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <a class="el" href="classshadertoy_1_1program__input.html" title="Represents an input texture to shader code. ">program_input</a> according to the arguments to its constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to <a class="el" href="classshadertoy_1_1program__input.html#a4435c46ab4c6f0e1f208a036b980cb4c" title="Create a new unnamed input. ">program_input::program_input</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classshadertoy_1_1program__input.html#a4435c46ab4c6f0e1f208a036b980cb4c" title="Create a new unnamed input. ">program_input::program_input</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the constructed <a class="el" href="classshadertoy_1_1program__input.html" title="Represents an input texture to shader code. ">program_input</a> </dd></dl>

</div>
</div>
<a id="a4c093077a39b284424fa74b605a58428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c093077a39b284424fa74b605a58428">&#9670;&nbsp;</a></span>make_ref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classshadertoy_1_1size__ref__interface.html">size_ref_interface</a>&lt;T&gt; &gt; shadertoy::make_ref </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshadertoy_1_1size__ref__interface.html">size_ref_interface</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>int_ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a reference to a <a class="el" href="classshadertoy_1_1size__ref__interface.html" title="Base interface for objects that can return a size object. ">size_ref_interface</a>&lt;T&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int_ref</td><td>Reference to a <a class="el" href="classshadertoy_1_1size__ref__interface.html" title="Base interface for objects that can return a size object. ">size_ref_interface</a>&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classshadertoy_1_1size__ref__interface__ref.html#a4c4e95f85ebc2dbca16042ce47a4579e" title="Build a new size_ref_interface&lt;T&gt; from a reference. ">size_ref_interface_ref::size_ref_interface_ref</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the constructed <a class="el" href="classshadertoy_1_1size__ref__interface__ref.html" title="Represents a reference to another size_ref_interface object. ">size_ref_interface_ref</a> </dd></dl>

</div>
</div>
<a id="a6cbaec8af3bfacd1da05b43e1c3ed4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cbaec8af3bfacd1da05b43e1c3ed4b3">&#9670;&nbsp;</a></span>make_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classshadertoy_1_1size__ref__interface.html">size_ref_interface</a>&lt;T&gt; &gt; shadertoy::make_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structshadertoy_1_1basic__size.html">basic_size</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to construct <a class="el" href="classshadertoy_1_1explicit__size.html" title="Represents a size object, wrapped in a size_ref_interface. ">explicit_size</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of the new <a class="el" href="classshadertoy_1_1explicit__size.html" title="Represents a size object, wrapped in a size_ref_interface. ">explicit_size</a> instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the size object elements</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classshadertoy_1_1explicit__size.html#a5c7488db2340e61996955c813c57e5e7" title="Build a new explicit_size from the size object size. ">explicit_size::explicit_size</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Unique pointer to a new <a class="el" href="classshadertoy_1_1explicit__size.html" title="Represents a size object, wrapped in a size_ref_interface. ">explicit_size</a> instance </dd></dl>

</div>
</div>
<a id="ab4d8f4b6358e1be1be77dfed1ccaf54a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d8f4b6358e1be1be77dfed1ccaf54a">&#9670;&nbsp;</a></span>make_size_getter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Callable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classshadertoy_1_1size__ref__interface.html">size_ref_interface</a>&lt;T&gt; &gt; shadertoy::make_size_getter </td>
          <td>(</td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>getter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to construct <a class="el" href="classshadertoy_1_1getter__size__ref.html" title="Represents a reference to a size object that is obtained through a callback. ">getter_size_ref</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">getter</td><td>Callable object for <a class="el" href="classshadertoy_1_1getter__size__ref.html" title="Represents a reference to a size object that is obtained through a callback. ">getter_size_ref</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classshadertoy_1_1getter__size__ref.html#aedf5d48ab3de5bbcc02216424ef2bd61" title="Buil a new getter_size_ref&lt;T&gt;. ">getter_size_ref::getter_size_ref</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the constructed <a class="el" href="classshadertoy_1_1getter__size__ref.html" title="Represents a reference to a size object that is obtained through a callback. ">getter_size_ref</a>&lt;T&gt; </dd></dl>

</div>
</div>
<a id="a585627de12dd33f83b734bcc0fcb7c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585627de12dd33f83b734bcc0fcb7c1d">&#9670;&nbsp;</a></span>make_size_ref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classshadertoy_1_1size__ref__interface.html">size_ref_interface</a>&lt;T&gt; &gt; shadertoy::make_size_ref </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structshadertoy_1_1basic__size.html">basic_size</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to construct <a class="el" href="classshadertoy_1_1explicit__size__ref.html" title="Represents a reference to a size object, wrapped in a size_ref_interface. ">explicit_size_ref</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of the new <a class="el" href="classshadertoy_1_1explicit__size__ref.html" title="Represents a reference to a size object, wrapped in a size_ref_interface. ">explicit_size_ref</a> instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the size object elements</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classshadertoy_1_1explicit__size__ref.html#a8bba32269e9edebac2c39cdce4e0a033" title="Build a new explicit_size_ref&lt;T&gt; from a reference. ">explicit_size_ref::explicit_size_ref</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Unique pointer to a new <a class="el" href="classshadertoy_1_1explicit__size__ref.html" title="Represents a reference to a size object, wrapped in a size_ref_interface. ">explicit_size_ref</a> instance </dd></dl>

</div>
</div>
<a id="a35ace5daa976d97ddcd4d4257e58ae22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ace5daa976d97ddcd4d4257e58ae22">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool shadertoy::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceshadertoy.html#a3747047719376bb7120d2ae3682208ff">output_name_info_t</a> &amp;&#160;</td>
          <td class="paramname"><em>name_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceshadertoy.html#acf320ab96814324ce2e033b901785897">output_name_t</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares a name information object with a name specification. </p>
<p>This is a partial equality relation where <code>name_info</code> == <code>name</code> if the value currently contained in the <code>name</code> variant matches the corresponding field in <code>name_info</code>. The result of this operator is the the negated result of this equality relation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_info</td><td>Name and location to test </td></tr>
    <tr><td class="paramname">name</td><td>Name specification (name or location) to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if <code>name</code> could be a specification for <code>name_info</code>, true otherwise </dd></dl>

</div>
</div>
<a id="a6d03ad55240494ec0bbb2a21e3279d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d03ad55240494ec0bbb2a21e3279d5f">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool shadertoy::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceshadertoy.html#a3747047719376bb7120d2ae3682208ff">output_name_info_t</a> &amp;&#160;</td>
          <td class="paramname"><em>name_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceshadertoy.html#acf320ab96814324ce2e033b901785897">output_name_t</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares a name information object with a name specification. </p>
<p>This is a partial equality relation where <code>name_info</code> == <code>name</code> if the value currently contained in the <code>name</code> variant matches the corresponding field in <code>name_info</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_info</td><td>Name and location to test </td></tr>
    <tr><td class="paramname">name</td><td>Name specification (name or location) to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>name</code> could be a specification for <code>name_info</code>, false otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceshadertoy.html">shadertoy</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
